<!-- xin ch√†o ng∆∞·ªùi l·∫°, m√¨nh l√† anhduc.onlien | m√¨nh c√≥ t√¨m ƒë∆∞·ª£c file code noel n√†y v√† fix l·∫°i, m√¨nh xin ph√©p share m·ªçi ng∆∞·ªùi ·∫°! -->
<!DOCTYPE html>
<html lang="VN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NOEL_V2</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: linear-gradient(
          to bottom,
          #0a1628 0%,
          #1a2940 25%,
          #0f1f38 50%,
          #1a3050 75%,
          #0d1b2a 100%
        );
        font-family: "Times New Roman", serif;
        position: relative;
      }

      /* Starry background effect */
      body::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: radial-gradient(
            2px 2px at 20% 30%,
            white,
            transparent
          ),
          radial-gradient(2px 2px at 60% 70%, white, transparent),
          radial-gradient(1px 1px at 50% 50%, white, transparent),
          radial-gradient(1px 1px at 80% 10%, white, transparent),
          radial-gradient(2px 2px at 90% 60%, white, transparent),
          radial-gradient(1px 1px at 33% 80%, white, transparent),
          radial-gradient(1px 1px at 15% 60%, white, transparent);
        background-size: 200% 200%;
        animation: twinkle 4s ease-in-out infinite;
        opacity: 0.5;
        z-index: 0;
      }

      @keyframes twinkle {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 0.8;
        }
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      /* UI Overlay - Minimalist */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-top: 40px;
        box-sizing: border-box;
        /* Remove transition here as we don't hide the whole layer anymore */
      }

      /* When hidden class is applied to specific elements */
      .ui-hidden {
        opacity: 0;
        pointer-events: none !important;
      }

      /* Loading */
      #loader {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.8s ease-out;
      }
      .loader-text {
        color: #d4af37;
        font-size: 14px;
        letter-spacing: 4px;
        margin-top: 20px;
        text-transform: uppercase;
        font-weight: 100;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 1px solid rgba(212, 175, 55, 0.2);
        border-top: 1px solid #d4af37;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Typography - Centerpiece */
      h1 {
        color: #fceea7;
        font-size: 56px;
        margin: 0;
        font-weight: 400;
        letter-spacing: 6px;
        text-shadow: 0 0 50px rgba(252, 238, 167, 0.6);
        background: linear-gradient(to bottom, #fff, #eebb66);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-family: "Cinzel", "Times New Roman", serif;
        opacity: 0.9;
        transition: opacity 0.5s ease; /* Ensure smooth transitions if needed */
      }

      /* Webcam feedback */
      #webcam-wrapper {
        position: absolute;
        bottom: 40px;
        right: 40px;
        width: 120px;
        height: 90px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        overflow: hidden;
        opacity: 0; /* Hidden by default but functional */
        pointer-events: none;
      }

      /* Christmas Message */
      .christmas-message {
        position: absolute;
        bottom: 50px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        font-size: 32px;
        font-weight: 700;
        text-align: center;
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.8),
          0 0 40px rgba(255, 215, 0, 0.6), 0 0 60px rgba(255, 0, 0, 0.4);
        font-family: "Cinzel", "Times New Roman", serif;
        letter-spacing: 3px;
        animation: glow 2s ease-in-out infinite alternate;
        z-index: 15;
        pointer-events: none;
      }

      @keyframes glow {
        from {
          text-shadow: 0 0 20px rgba(255, 255, 255, 0.8),
            0 0 40px rgba(255, 215, 0, 0.6), 0 0 60px rgba(255, 0, 0, 0.4);
        }
        to {
          text-shadow: 0 0 30px rgba(255, 255, 255, 1),
            0 0 60px rgba(255, 215, 0, 0.8), 0 0 90px rgba(255, 0, 0, 0.6);
        }
      }

      /* Snowflakes */
      .snowflake {
        position: absolute;
        top: -10px;
        z-index: 9;
        color: #fff;
        font-size: 1em;
        pointer-events: none;
        animation: fall linear infinite;
        text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
      }

      @keyframes fall {
        to {
          transform: translateY(100vh) rotate(360deg);
        }
      }

      /* Fireworks */
      .firework {
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        pointer-events: none;
        z-index: 8;
      }

      @keyframes firework-launch {
        0% {
          transform: translateY(0);
          opacity: 1;
        }
        100% {
          transform: translateY(-200px);
          opacity: 0;
        }
      }

      @keyframes firework-explode {
        0% {
          transform: translate(0, 0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(var(--x), var(--y)) scale(0);
          opacity: 0;
        }
      }

      /* Greeting Message */
      .greeting-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Great Vibes", "Dancing Script", cursive;
        font-size: 72px;
        color: #fff;
        text-align: center;
        text-shadow: 0 0 30px rgba(255, 215, 0, 0.8),
          0 0 60px rgba(255, 100, 100, 0.6), 0 5px 20px rgba(0, 0, 0, 0.5);
        z-index: 20;
        pointer-events: none;
        animation: greeting-pulse 3s ease-in-out infinite;
        line-height: 1.4;
      }

      .greeting-text .small {
        font-size: 42px;
        display: block;
        margin-top: 10px;
        font-family: "Playfair Display", serif;
        letter-spacing: 4px;
      }

      @keyframes greeting-pulse {
        0%,
        100% {
          transform: translate(-50%, -50%) scale(1);
          text-shadow: 0 0 30px rgba(255, 215, 0, 0.8),
            0 0 60px rgba(255, 100, 100, 0.6), 0 5px 20px rgba(0, 0, 0, 0.5);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.05);
          text-shadow: 0 0 40px rgba(255, 215, 0, 1),
            0 0 80px rgba(255, 100, 100, 0.8), 0 5px 30px rgba(0, 0, 0, 0.6);
        }
      }
    </style>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap");
      @import url("https://fonts.googleapis.com/css2?family=Great+Vibes&family=Playfair+Display:wght@700&family=Dancing+Script:wght@700&display=swap");
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
      }
    </script>
  </head>
  <body>
    <div id="loader">
      <div class="spinner"></div>
      <div class="loader-text">Loading Holiday Magic</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
      <h1></h1>
    </div>

    <!-- Greeting Text -->
    <div class="greeting-text">
      <br />
      <span
        class="small"
        style="
          font-family: 'Dancing Script', 'Great Vibes', cursive;
          font-weight: 700;
          font-size: 48px;
        "
        >‚õÑ Marry Christmas ‚õÑ<br />
      </span>
    </div>

    <!-- Webcam hidden structure -->
    <div id="webcam-wrapper">
      <video id="webcam" autoplay playsinline style="display: none"></video>
      <canvas id="webcam-preview"></canvas>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
      import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

      // --- CONFIGURATION ---
      const CONFIG = {
        colors: {
          bg: 0x0a1628,
          champagneGold: 0xffd966,
          deepGreen: 0x03180a,
          accentRed: 0x990000,
          silver: 0xc0c0c0,
          blue: 0x4169e1,
          purple: 0x9370db,
          pink: 0xff69b4,
        },
        particles: {
          count: 2500,
          dustCount: 3500,
          treeHeight: 24,
          treeRadius: 8,
        },
        camera: {
          z: 50,
        },
      };

      const STATE = {
        mode: "TREE",
        focusIndex: -1,
        focusTarget: null,
        hand: { detected: false, x: 0, y: 0 },
        rotation: { x: 0, y: 0 },
      };

      let scene, camera, renderer, composer;
      let mainGroup;
      let clock = new THREE.Clock();
      let particleSystem = [];
      let photoMeshGroup = new THREE.Group();
      let handLandmarker, video, webcamCanvas, webcamCtx;
      let caneTexture;

      async function init() {
        initThree();
        setupEnvironment();
        setupLights();
        createTextures();
        createParticles();
        createDust();
        setupPostProcessing();
        setupEvents();
        await initMediaPipe();

        // Load images from public folder
        loadImagesFromPublic();

        // Create snowfall effect
        createSnowfall();

        // Create fireworks
        createFireworks();

        const loader = document.getElementById("loader");
        loader.style.opacity = 0;
        setTimeout(() => loader.remove(), 800);

        animate();
      }

      // Create fireworks effect
      function createFireworks() {
        function launchFirework() {
          const x = Math.random() * window.innerWidth;
          const y = window.innerHeight;
          const targetY = Math.random() * (window.innerHeight * 0.5);

          const colors = [
            "#ff0000",
            "#00ff00",
            "#0000ff",
            "#ffff00",
            "#ff00ff",
            "#00ffff",
            "#ffd700",
            "#ff6600",
          ];
          const color = colors[Math.floor(Math.random() * colors.length)];

          // Create launch trail
          const trail = document.createElement("div");
          trail.className = "firework";
          trail.style.left = x + "px";
          trail.style.top = y + "px";
          trail.style.backgroundColor = color;
          trail.style.boxShadow = `0 0 10px ${color}`;
          document.body.appendChild(trail);

          // Animate launch
          trail.style.animation = "firework-launch 1s ease-out forwards";
          trail.style.transform = `translateY(-${y - targetY}px)`;

          // Explode after launch
          setTimeout(() => {
            trail.remove();

            // Random firework type
            const type = Math.random();
            if (type < 0.3) {
              explodeCircle(x, targetY, color);
            } else if (type < 0.5) {
              explodeHeart(x, targetY, color);
            } else if (type < 0.7) {
              explodeRing(x, targetY, color);
            } else if (type < 0.85) {
              explodeWillow(x, targetY, color);
            } else {
              explodeStar(x, targetY, color);
            }
          }, 1000);
        }

        // Circle explosion
        function explodeCircle(x, y, color) {
          const particleCount = 60;
          for (let i = 0; i < particleCount; i++) {
            createParticle(
              x,
              y,
              color,
              i,
              particleCount,
              100 + Math.random() * 100
            );
          }
        }

        // Heart shape
        function explodeHeart(x, y, color) {
          const particleCount = 80;
          for (let i = 0; i < particleCount; i++) {
            const t = (i / particleCount) * Math.PI * 2;
            const heartX = 16 * Math.pow(Math.sin(t), 3);
            const heartY = -(
              13 * Math.cos(t) -
              5 * Math.cos(2 * t) -
              2 * Math.cos(3 * t) -
              Math.cos(4 * t)
            );

            const particle = document.createElement("div");
            particle.className = "firework";
            particle.style.left = x + "px";
            particle.style.top = y + "px";
            particle.style.backgroundColor = color;
            particle.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;

            particle.style.setProperty("--x", heartX * 8 + "px");
            particle.style.setProperty("--y", heartY * 8 + "px");
            particle.style.animation =
              "firework-explode 1.5s ease-out forwards";

            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 1500);
          }
        }

        // Ring explosion
        function explodeRing(x, y, color) {
          const rings = 3;
          for (let r = 0; r < rings; r++) {
            const particleCount = 40;
            const delay = r * 100;
            const radius = 80 + r * 40;

            setTimeout(() => {
              for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const xVel = Math.cos(angle) * radius;
                const yVel = Math.sin(angle) * radius;

                const particle = document.createElement("div");
                particle.className = "firework";
                particle.style.left = x + "px";
                particle.style.top = y + "px";
                particle.style.backgroundColor = color;
                particle.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;

                particle.style.setProperty("--x", xVel + "px");
                particle.style.setProperty("--y", yVel + "px");
                particle.style.animation =
                  "firework-explode 1.5s ease-out forwards";

                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 1500);
              }
            }, delay);
          }
        }

        // Willow/cascade effect
        function explodeWillow(x, y, color) {
          const particleCount = 100;
          for (let i = 0; i < particleCount; i++) {
            const angle = (Math.PI * 2 * i) / particleCount;
            const velocity = 120 + Math.random() * 80;
            const xVel = Math.cos(angle) * velocity;
            const yVel = Math.sin(angle) * velocity * 0.5;

            const particle = document.createElement("div");
            particle.className = "firework";
            particle.style.left = x + "px";
            particle.style.top = y + "px";

            // Gradient colors for willow
            const gradientColors = ["#ffd700", "#ff8c00", "#ff4500"];
            particle.style.backgroundColor =
              gradientColors[Math.floor(Math.random() * gradientColors.length)];
            particle.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;

            particle.style.setProperty("--x", xVel + "px");
            particle.style.setProperty("--y", yVel + 200 + "px");
            particle.style.animation = "firework-explode 2s ease-out forwards";

            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 2000);
          }
        }

        // Star shape
        function explodeStar(x, y, color) {
          const points = 5;
          const particlesPerLine = 15;

          for (let i = 0; i < points; i++) {
            const angle = (Math.PI * 2 * i) / points - Math.PI / 2;

            for (let j = 0; j < particlesPerLine; j++) {
              const distance = (j / particlesPerLine) * 150;
              const xVel = Math.cos(angle) * distance;
              const yVel = Math.sin(angle) * distance;

              setTimeout(() => {
                const particle = document.createElement("div");
                particle.className = "firework";
                particle.style.left = x + "px";
                particle.style.top = y + "px";
                particle.style.backgroundColor = color;
                particle.style.boxShadow = `0 0 25px ${color}, 0 0 50px ${color}`;

                particle.style.setProperty("--x", xVel + "px");
                particle.style.setProperty("--y", yVel + "px");
                particle.style.animation =
                  "firework-explode 1.2s ease-out forwards";

                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 1200);
              }, j * 20);
            }
          }
        }

        function createParticle(x, y, color, index, total, velocity) {
          const particle = document.createElement("div");
          particle.className = "firework";
          particle.style.left = x + "px";
          particle.style.top = y + "px";
          particle.style.backgroundColor = color;
          particle.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;

          const angle = (Math.PI * 2 * index) / total;
          const xVel = Math.cos(angle) * velocity;
          const yVel = Math.sin(angle) * velocity;

          particle.style.setProperty("--x", xVel + "px");
          particle.style.setProperty("--y", yVel + "px");
          particle.style.animation = "firework-explode 1.5s ease-out forwards";

          document.body.appendChild(particle);
          setTimeout(() => particle.remove(), 1500);
        }

        // Launch fireworks at random intervals
        function scheduledLaunch() {
          launchFirework();
          setTimeout(scheduledLaunch, 800 + Math.random() * 1500);
        }

        setTimeout(scheduledLaunch, 2000);
      }

      // Create snowfall effect
      function createSnowfall() {
        // Diverse collection of snowflakes and winter/Christmas symbols
        const snowflakes = [
          "‚ùÑ",
          "‚ùÖ",
          "‚ùÜ",
          "‚ùâ",
          "‚úª",
          "‚úº",
          "‚ùã",
          "‚ú∫",
          "‚úπ",
          "‚ú∏",
          "‚ú∑",
          "‚ú∂",
          "‚úµ",
          "‚ú¥",
          "‚ú≥",
          "‚ú≤",
          "‚ú±",
          "‚ú∞",
          "‚Åï",
          "‚ÅÇ",
          "‚úΩ",
          "‚úæ",
          "‚úø",
          "‚ùÄ",
          "‚ùÅ",
          "‚ãÜ",
          "‚ú¢",
          "‚ú£",
          "‚ú§",
          "‚ú•",
          "üå®",
          "üåü",
          "‚≠ê",
          "‚ú®",
          "üí´",
          "‚õÑ",
          "üéÑ",
          "üîî",
          "üéÖ",
          "üéÅ",
          "üïØ",
          "üå†",
        ];
        const numberOfSnowflakes = 150;

        for (let i = 0; i < numberOfSnowflakes; i++) {
          const snowflake = document.createElement("div");
          snowflake.className = "snowflake";
          snowflake.innerHTML =
            snowflakes[Math.floor(Math.random() * snowflakes.length)];

          // Random horizontal position
          snowflake.style.left = Math.random() * 100 + "vw";

          // Random size
          const size = Math.random() * 1.5 + 0.5;
          snowflake.style.fontSize = size + "em";

          // Random animation duration (fall speed)
          const duration = Math.random() * 10 + 10;
          snowflake.style.animationDuration = duration + "s";

          // Random delay
          snowflake.style.animationDelay = Math.random() * 10 + "s";

          // Random opacity
          snowflake.style.opacity = Math.random() * 0.6 + 0.4;

          document.body.appendChild(snowflake);
        }
      }

      function initThree() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.bg);
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.01);

        camera = new THREE.PerspectiveCamera(
          42,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 2, CONFIG.camera.z);

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.2;
        container.appendChild(renderer.domElement);

        mainGroup = new THREE.Group();
        scene.add(mainGroup);
      }

      function setupEnvironment() {
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(
          new RoomEnvironment(),
          0.04
        ).texture;
      }

      function setupLights() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const innerLight = new THREE.PointLight(0xffaa00, 2, 20);
        innerLight.position.set(0, 5, 0);
        mainGroup.add(innerLight);

        const spotGold = new THREE.SpotLight(0xffcc66, 1200);
        spotGold.position.set(30, 40, 40);
        spotGold.angle = 0.5;
        spotGold.penumbra = 0.5;
        scene.add(spotGold);

        const spotBlue = new THREE.SpotLight(0x6688ff, 600);
        spotBlue.position.set(-30, 20, -30);
        scene.add(spotBlue);

        const fill = new THREE.DirectionalLight(0xffeebb, 0.8);
        fill.position.set(0, 0, 50);
        scene.add(fill);
      }

      function setupPostProcessing() {
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        );
        bloomPass.threshold = 0.7;
        bloomPass.strength = 0.45;
        bloomPass.radius = 0.4;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
      }

      function createTextures() {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, 128, 128);
        ctx.fillStyle = "#880000";
        ctx.beginPath();
        for (let i = -128; i < 256; i += 32) {
          ctx.moveTo(i, 0);
          ctx.lineTo(i + 32, 128);
          ctx.lineTo(i + 16, 128);
          ctx.lineTo(i - 16, 0);
        }
        ctx.fill();
        caneTexture = new THREE.CanvasTexture(canvas);
        caneTexture.wrapS = THREE.RepeatWrapping;
        caneTexture.wrapT = THREE.RepeatWrapping;
        caneTexture.repeat.set(3, 3);
      }

      class Particle {
        constructor(mesh, type, isDust = false) {
          this.mesh = mesh;
          this.type = type;
          this.isDust = isDust;

          this.posTree = new THREE.Vector3();
          this.posScatter = new THREE.Vector3();
          this.baseScale = mesh.scale.x;

          // Individual Spin Speed
          // Photos spin slower to be readable
          const speedMult = type === "PHOTO" ? 0.3 : 2.0;

          this.spinSpeed = new THREE.Vector3(
            (Math.random() - 0.5) * speedMult,
            (Math.random() - 0.5) * speedMult,
            (Math.random() - 0.5) * speedMult
          );

          this.calculatePositions();
        }

        calculatePositions() {
          // TREE: Tight Spiral
          const h = CONFIG.particles.treeHeight;
          const halfH = h / 2;
          let t = Math.random();
          t = Math.pow(t, 0.45); // Reduced to 0.45 for much denser bottom distribution
          const y = t * h - halfH;
          let rMax = CONFIG.particles.treeRadius * (1.0 - t); // Back to original shape
          if (rMax < 0.5) rMax = 0.5;
          const angle = t * 50 * Math.PI + Math.random() * Math.PI;
          const r = rMax * (0.8 + Math.random() * 0.4);
          this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

          // SCATTER: 3D Sphere
          let rScatter = this.isDust
            ? 12 + Math.random() * 20
            : 8 + Math.random() * 12;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          this.posScatter.set(
            rScatter * Math.sin(phi) * Math.cos(theta),
            rScatter * Math.sin(phi) * Math.sin(theta),
            rScatter * Math.cos(phi)
          );
        }

        update(dt, mode, focusTargetMesh) {
          let target = this.posTree;

          if (mode === "SCATTER") target = this.posScatter;
          else if (mode === "FOCUS") {
            if (this.mesh === focusTargetMesh) {
              const desiredWorldPos = new THREE.Vector3(0, 2, 35);
              const invMatrix = new THREE.Matrix4()
                .copy(mainGroup.matrixWorld)
                .invert();
              target = desiredWorldPos.applyMatrix4(invMatrix);
            } else {
              target = this.posScatter;
            }
          }

          // Movement Easing
          const lerpSpeed =
            mode === "FOCUS" && this.mesh === focusTargetMesh ? 5.0 : 2.0;
          this.mesh.position.lerp(target, lerpSpeed * dt);

          // Rotation Logic - CRITICAL: Ensure spin happens in Scatter
          if (mode === "SCATTER") {
            this.mesh.rotation.x += this.spinSpeed.x * dt;
            this.mesh.rotation.y += this.spinSpeed.y * dt;
            this.mesh.rotation.z += this.spinSpeed.z * dt; // Added Z for more natural tumble
          } else if (mode === "TREE") {
            // Reset rotations slowly
            this.mesh.rotation.x = THREE.MathUtils.lerp(
              this.mesh.rotation.x,
              0,
              dt
            );
            this.mesh.rotation.z = THREE.MathUtils.lerp(
              this.mesh.rotation.z,
              0,
              dt
            );
            this.mesh.rotation.y += 0.5 * dt;
          }

          if (mode === "FOCUS" && this.mesh === focusTargetMesh) {
            this.mesh.lookAt(camera.position);
          }

          // Scale Logic
          let s = this.baseScale;
          if (this.isDust) {
            s =
              this.baseScale *
              (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
            if (mode === "TREE") s = 0;
          } else if (mode === "SCATTER" && this.type === "PHOTO") {
            // Large preview size in scatter
            s = this.baseScale * 2.5;
          } else if (mode === "FOCUS") {
            if (this.mesh === focusTargetMesh) s = 4.5;
            else s = this.baseScale * 0.8;
          }

          this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);
        }
      }

      // --- CREATION ---
      function createParticles() {
        const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
        const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);

        // Foliage geometries - diverse shapes for green needles
        const coneGeo = new THREE.ConeGeometry(0.3, 0.6, 6);
        const tetraGeo = new THREE.TetrahedronGeometry(0.4, 0);
        const pyramidGeo = new THREE.ConeGeometry(0.4, 0.5, 4);
        const cylinderGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.6, 6);
        const octaGeo = new THREE.OctahedronGeometry(0.35, 0);
        const torusGeo = new THREE.TorusGeometry(0.3, 0.12, 8, 6);

        // Candy cane geometry
        const curve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, -0.5, 0),
          new THREE.Vector3(0, 0.3, 0),
          new THREE.Vector3(0.1, 0.5, 0),
          new THREE.Vector3(0.3, 0.4, 0),
        ]);
        const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

        // Gift box geometry
        const giftGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);

        // Star ornament geometry
        const starOrnamentGeo = new THREE.OctahedronGeometry(0.4, 0);

        // Bell geometry (using cone + sphere)
        const bellBodyGeo = new THREE.ConeGeometry(0.3, 0.4, 8);
        const bellTopGeo = new THREE.SphereGeometry(0.1, 8, 8);

        // Light bulb geometry
        const lightGeo = new THREE.SphereGeometry(0.3, 16, 16);

        // Green foliage material
        const greenMat = new THREE.MeshStandardMaterial({
          color: 0x1a5c1a,
          metalness: 0.1,
          roughness: 0.9,
          emissive: 0x0a3a0a,
          emissiveIntensity: 0.2,
        });

        // Red ornament balls
        const redMat = new THREE.MeshPhysicalMaterial({
          color: 0xcc0000,
          metalness: 0.5,
          roughness: 0.1,
          clearcoat: 1.0,
          emissive: 0x660000,
          emissiveIntensity: 0.3,
        });

        // Gold ornament balls
        const goldMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          metalness: 1.0,
          roughness: 0.1,
          envMapIntensity: 2.0,
          emissive: 0x886600,
          emissiveIntensity: 0.4,
        });

        // Silver/White ornament balls
        const silverMat = new THREE.MeshStandardMaterial({
          color: 0xe8e8e8,
          metalness: 1.0,
          roughness: 0.1,
          emissive: 0x666666,
          emissiveIntensity: 0.2,
        });

        // Candy cane material
        const candyMat = new THREE.MeshStandardMaterial({
          map: caneTexture,
          roughness: 0.4,
        });

        // Gift box materials
        const redGiftMat = new THREE.MeshStandardMaterial({
          color: 0xdd0000,
          roughness: 0.5,
        });

        const greenGiftMat = new THREE.MeshStandardMaterial({
          color: 0x00aa00,
          roughness: 0.5,
        });

        const blueGiftMat = new THREE.MeshStandardMaterial({
          color: 0x0066cc,
          roughness: 0.5,
        });

        // Star ornament material
        const starOrnamentMat = new THREE.MeshStandardMaterial({
          color: 0xffdd00,
          metalness: 1.0,
          roughness: 0.2,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5,
        });

        // Bell material
        const bellMat = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          metalness: 1.0,
          roughness: 0.3,
        });

        // Light bulb materials (colorful)
        const redLightMat = new THREE.MeshStandardMaterial({
          color: 0xff0000,
          emissive: 0xff0000,
          emissiveIntensity: 0.8,
        });

        const yellowLightMat = new THREE.MeshStandardMaterial({
          color: 0xffff00,
          emissive: 0xffff00,
          emissiveIntensity: 0.8,
        });

        const blueLightMat = new THREE.MeshStandardMaterial({
          color: 0x0088ff,
          emissive: 0x0088ff,
          emissiveIntensity: 0.8,
        });

        const greenLightMat = new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          emissive: 0x00ff00,
          emissiveIntensity: 0.8,
        });

        for (let i = 0; i < CONFIG.particles.count; i++) {
          const rand = Math.random();
          let mesh, type;

          if (rand < 0.6) {
            // 60% green foliage - diverse shapes
            const foliageRand = Math.random();
            if (foliageRand < 0.2) {
              mesh = new THREE.Mesh(coneGeo, greenMat);
              type = "FOLIAGE_CONE";
            } else if (foliageRand < 0.35) {
              mesh = new THREE.Mesh(tetraGeo, greenMat);
              type = "FOLIAGE_TETRA";
            } else if (foliageRand < 0.5) {
              mesh = new THREE.Mesh(pyramidGeo, greenMat);
              type = "FOLIAGE_PYRAMID";
            } else if (foliageRand < 0.65) {
              mesh = new THREE.Mesh(cylinderGeo, greenMat);
              type = "FOLIAGE_CYLINDER";
            } else if (foliageRand < 0.8) {
              mesh = new THREE.Mesh(octaGeo, greenMat);
              type = "FOLIAGE_OCTA";
            } else if (foliageRand < 0.9) {
              mesh = new THREE.Mesh(torusGeo, greenMat);
              type = "FOLIAGE_TORUS";
            } else {
              mesh = new THREE.Mesh(sphereGeo, greenMat);
              type = "FOLIAGE_SPHERE";
            }
          } else if (rand < 0.7) {
            // 10% red ornament balls
            mesh = new THREE.Mesh(sphereGeo, redMat);
            type = "RED_BALL";
          } else if (rand < 0.74) {
            // 4% gold ornament balls
            mesh = new THREE.Mesh(sphereGeo, goldMat);
            type = "GOLD_BALL";
          } else if (rand < 0.82) {
            // 8% silver ornament balls
            mesh = new THREE.Mesh(sphereGeo, silverMat);
            type = "SILVER_BALL";
          } else if (rand < 0.87) {
            // 5% candy canes
            mesh = new THREE.Mesh(candyGeo, candyMat);
            type = "CANDY_CANE";
          } else if (rand < 0.91) {
            // 4% gift boxes
            const giftMats = [redGiftMat, greenGiftMat, blueGiftMat];
            mesh = new THREE.Mesh(
              giftGeo,
              giftMats[Math.floor(Math.random() * 3)]
            );
            type = "GIFT";
          } else if (rand < 0.94) {
            // 3% star ornaments
            mesh = new THREE.Mesh(starOrnamentGeo, starOrnamentMat);
            type = "STAR_ORNAMENT";
          } else if (rand < 0.96) {
            // 2% bells
            const bellGroup = new THREE.Group();
            const body = new THREE.Mesh(bellBodyGeo, bellMat);
            const top = new THREE.Mesh(bellTopGeo, bellMat);
            top.position.y = 0.2;
            bellGroup.add(body);
            bellGroup.add(top);
            mesh = bellGroup;
            type = "BELL";
          } else {
            // 4% colorful lights
            const lightMats = [
              redLightMat,
              yellowLightMat,
              blueLightMat,
              greenLightMat,
            ];
            mesh = new THREE.Mesh(
              lightGeo,
              lightMats[Math.floor(Math.random() * 4)]
            );
            type = "LIGHT";
          }

          const s = 0.4 + Math.random() * 0.5;
          mesh.scale.set(s, s, s);
          mesh.rotation.set(
            Math.random() * 6,
            Math.random() * 6,
            Math.random() * 6
          );

          mainGroup.add(mesh);
          particleSystem.push(new Particle(mesh, type, false));
        }

        const starGeo = new THREE.OctahedronGeometry(1.2, 0);
        const starMat = new THREE.MeshStandardMaterial({
          color: 0xffdd88,
          emissive: 0xffaa00,
          emissiveIntensity: 1.0,
          metalness: 1.0,
          roughness: 0,
        });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
        mainGroup.add(star);

        mainGroup.add(photoMeshGroup);
      }

      function createDust() {
        const geo = new THREE.TetrahedronGeometry(0.08, 0);
        const mat = new THREE.MeshBasicMaterial({
          color: 0xffeebb,
          transparent: true,
          opacity: 0.8,
        });

        for (let i = 0; i < CONFIG.particles.dustCount; i++) {
          const mesh = new THREE.Mesh(geo, mat);
          mesh.scale.setScalar(0.5 + Math.random());
          mainGroup.add(mesh);
          particleSystem.push(new Particle(mesh, "DUST", true));
        }
      }
      function addPhotoToScene(texture) {
        const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
        const frameMat = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.champagneGold,
          metalness: 1.0,
          roughness: 0.1,
        });
        const frame = new THREE.Mesh(frameGeo, frameMat);

        const photoGeo = new THREE.PlaneGeometry(1.2, 1.2);
        const photoMat = new THREE.MeshBasicMaterial({ map: texture });
        const photo = new THREE.Mesh(photoGeo, photoMat);
        photo.position.z = 0.04;

        const group = new THREE.Group();
        group.add(frame);
        group.add(photo);

        const s = 0.8;
        group.scale.set(s, s, s);

        photoMeshGroup.add(group);
        particleSystem.push(new Particle(group, "PHOTO", false));
      }

      function loadImagesFromPublic() {
        const imageFiles = [
          "1.jpg",
          "2.jpg",
          "3.jpg",
          "4.jpg",
          "5.jpg",
          "6.jpg",
          "7.jpg",
          "8.jpg",
          "9.jpg",
          "10.jpg",
          "11.jpg",
          "12.jpg",
          "13.jpg",
          "14.jpg",
          "15.jpg",
          "16.jpg",
          "17.jpg",
          "18.jpg",
          "19.jpg",
          "20.jpg",
          "21.jpg",
          "22.jpg",
          "23.jpg",
          "24.jpg",
          "25.jpg",
          "26.jpg",
          "27.jpg",
          "28.jpg",
          "29.jpg",
          "top.jpg",
        ];

        const loader = new THREE.TextureLoader();
        imageFiles.forEach((filename) => {
          loader.load(
            `public/${filename}`,
            (texture) => {
              texture.colorSpace = THREE.SRGBColorSpace;
              addPhotoToScene(texture);
            },
            undefined,
            (error) => {
              console.warn(`Could not load image: ${filename}`);
            }
          );
        });
      }

      // --- MEDIAPIPE ---
      async function initMediaPipe() {
        video = document.getElementById("webcam");
        webcamCanvas = document.getElementById("webcam-preview");
        webcamCtx = webcamCanvas.getContext("2d");
        webcamCanvas.width = 160;
        webcamCanvas.height = 120;

        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numHands: 1,
        });

        if (navigator.mediaDevices?.getUserMedia) {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
          });
          video.srcObject = stream;
          video.addEventListener("loadeddata", predictWebcam);
        }
      }

      let lastVideoTime = -1;
      async function predictWebcam() {
        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime;
          if (handLandmarker) {
            const result = handLandmarker.detectForVideo(
              video,
              performance.now()
            );
            processGestures(result);
          }
        }
        requestAnimationFrame(predictWebcam);
      }

      function processGestures(result) {
        if (result.landmarks && result.landmarks.length > 0) {
          STATE.hand.detected = true;
          const lm = result.landmarks[0];
          STATE.hand.x = (lm[9].x - 0.5) * 2;
          STATE.hand.y = (lm[9].y - 0.5) * 2;

          const thumb = lm[4];
          const index = lm[8];
          const wrist = lm[0];
          const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
          const tips = [lm[8], lm[12], lm[16], lm[20]];
          let avgDist = 0;
          tips.forEach(
            (t) => (avgDist += Math.hypot(t.x - wrist.x, t.y - wrist.y))
          );
          avgDist /= 4;

          if (pinchDist < 0.05) {
            if (STATE.mode !== "FOCUS") {
              STATE.mode = "FOCUS";
              const photos = particleSystem.filter((p) => p.type === "PHOTO");
              if (photos.length)
                STATE.focusTarget =
                  photos[Math.floor(Math.random() * photos.length)].mesh;
            }
          } else if (avgDist < 0.25) {
            STATE.mode = "TREE";
            STATE.focusTarget = null;
          } else if (avgDist > 0.4) {
            STATE.mode = "SCATTER";
            STATE.focusTarget = null;
          }
        } else {
          STATE.hand.detected = false;
        }
      }

      function setupEvents() {
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          composer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();

        // Rotation Logic
        if (STATE.mode === "SCATTER" && STATE.hand.detected) {
          const targetRotY = STATE.hand.x * Math.PI * 0.9;
          const targetRotX = STATE.hand.y * Math.PI * 0.25;
          STATE.rotation.y += (targetRotY - STATE.rotation.y) * 3.0 * dt;
          STATE.rotation.x += (targetRotX - STATE.rotation.x) * 3.0 * dt;
        } else {
          if (STATE.mode === "TREE") {
            STATE.rotation.y += 0.3 * dt;
            STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;
          } else {
            STATE.rotation.y += 0.1 * dt;
          }
        }

        mainGroup.rotation.y = STATE.rotation.y;
        mainGroup.rotation.x = STATE.rotation.x;

        particleSystem.forEach((p) =>
          p.update(dt, STATE.mode, STATE.focusTarget)
        );
        composer.render();
      }

      init();
    </script>
  </body>
</html>
